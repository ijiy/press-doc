import{_ as i,c as a,a0 as e,o as u}from"./chunks/framework.Bakaa70P.js";const m=JSON.parse('{"title":"微信小程序 - 原生","description":"","frontmatter":{},"headers":[],"relativePath":"uniapp/kf-wx/miniprogram.md","filePath":"uniapp/kf-wx/miniprogram.md","lastUpdated":1725247280000}'),o={name:"uniapp/kf-wx/miniprogram.md"};function t(n,l,r,p,d,s){return u(),a("div",null,l[0]||(l[0]=[e('<h1 id="微信小程序-原生" tabindex="-1">微信小程序 - 原生 <a class="header-anchor" href="#微信小程序-原生" aria-label="Permalink to &quot;微信小程序 - 原生&quot;">​</a></h1><h2 id="性能" tabindex="-1">性能 <a class="header-anchor" href="#性能" aria-label="Permalink to &quot;性能&quot;">​</a></h2><ul><li><p>数据预拉取</p><ul><li>公众号配置 <ul><li>开发管理 -&gt; 开发设置 -&gt; 数据预加载</li></ul></li><li>在微信加载完小程序前, 预先获取数据, 直到获取完, 再打开小程序, 基本上在加载小程序过程就完成预加载</li><li>背景: 因为 app onLaunch 和 page onload 都是打开小程序后异步实现的, 而大多数是期望在进入 page onload 前获取完全局数据 <ul><li>为确保达到该目的, 以往总是用一个中间页作为过度, 以图便利; 或在需要的页面 await, 以确保全局数据加载完成</li></ul></li></ul></li><li><p>分包</p><ul><li>作用 <ul><li>将页面从主包中分离 (包括静态资源), 作为分包在使用时按需加载</li></ul></li><li>优点 <ul><li>优化小程序首次启动的下载时间</li><li>多人开发可以更好的解耦协作</li><li>突破体积上限</li></ul></li><li>限制 <ul><li>整个小程序所有分包大小不超过 20M</li><li>单个分包/主包大小不能超过 2M</li></ul></li></ul></li><li><p>独立分包</p><ul><li>习惯作为默认入口页面, 配置预加载主包</li><li>优点 <ul><li>不不依赖主包即可运行</li><li>很大程度上提升分包页面的启动速度</li><li>可以配置多个独立分包</li></ul></li><li>缺点 <ul><li>无法引入其它 js, 可引入 app.wxss 外的 wxss 文件; 无法利用大部分公共资源, 不利于维护</li></ul></li></ul></li><li><p>分包异步化</p><ul><li>require, 在分包中异步引入 js 或 插件, 以避免加载分包而阻塞代码运行</li></ul></li><li><p>自定义组件</p><ul><li>无法使用 app.wxss</li><li>按需注入 <ul><li>app.json 添加 <code>&quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;</code></li><li>只有打开页面, 才会被注入需要的组件</li><li>Component, 会被重复实例化, 但页面结构不会</li></ul></li><li>占位组件 <ul><li>页面 json 添加 <code>componentPlaceholder</code></li><li>页面或组件渲染完毕前, 使用占位组件, 渲染完毕后, 注入自定义组件</li><li>要求立即显示的模块, 不要使用占位组件</li></ul></li></ul></li><li><p>静态初始渲染</p><ul><li>使用 <ul><li>页面 json 添加 &quot;initialRenderingCache&quot;: &quot;static&quot;</li></ul></li><li>作用 <ul><li>页面第一次加载会渲染 data, 之后即使 unload 再重新进入页面也不会再渲染 data, 且 data 的属性不会再被初始化赋值</li><li><code>data</code> 有 onload 前需要变动的数据, 要在 onload 或组件的 lifetimes.attached 中处理</li></ul></li><li>优点 <ul><li>加快小程序销毁重新打开的启动速度</li></ul></li></ul></li><li><p>极限分页</p><ul><li>解决DOM数量和大小限制阻塞加载 <ul><li>同层级的DOM条数接近一定上限, 就会卡</li></ul></li><li>要求每条数据都固定高度</li><li>无论多次请求分页, 还是一次大量数据的本地分页, 都使用极限分页组件来优化渲染</li><li>使用 <ul><li>将一维数组渲染<code>[所有页n条数据]</code>改成二维数组渲染<code>[...[每页n条数据]]</code><ul><li>每次分页只渲染<code>setData</code>当前页下标的数组</li><li>在同层级上虽缩小10倍(一分页的数据量, 理论值, 实际肯定达不到这个值)的DOM条数, 但依旧会达到极限</li></ul></li><li>滚动到可视区域渲染内容, 非可视区域用空标签占位 <ul><li>利用微信接口 IntersectionObserver</li><li>不仅避免了DOM数量上的限制, 也避免了DOM存储大小的限制, 理论上实现分页无上限</li></ul></li></ul></li></ul></li><li><p>调用地图等API, 非常消耗电量和内存, 对设备性能要求较高</p><ul><li>尽量避免频繁调用, 公用初始化, 缓存相关变量</li></ul></li></ul><h2 id="功能" tabindex="-1">功能 <a class="header-anchor" href="#功能" aria-label="Permalink to &quot;功能&quot;">​</a></h2><ul><li>slot <ul><li>无法携带数据 <ul><li>抽象节点 <ul><li>属于 自定义组件</li><li>可以省很多开发操作, 更便于组件的使用, 不用传 pageSize 等</li><li>但每条数据就是一个单例的抽象节点, 而这个抽象节点也是剥离页面单独存在的组件</li><li>事件要通过 triggerEvent 到外层</li></ul></li><li>虚拟节点 <ul><li>组件中, 结合每条数据的唯一 name 遍历 slot 元素</li><li>页面中, 同时遍历每条数据, 其中 slot 属性值对应 name, 该部分不作渲染, 相当于虚拟DOM的存在</li></ul></li></ul></li><li>不能用在 block 上 <ul><li>否则在条件语句中会脱离结构, 默认slot不生效</li></ul></li></ul></li></ul><h2 id="双向绑定" tabindex="-1">双向绑定 <a class="header-anchor" href="#双向绑定" aria-label="Permalink to &quot;双向绑定&quot;">​</a></h2><ul><li><p>普通的属性的绑定是单向的</p></li><li><p>简易的实现双向绑定, 不过只能绑定一个字段, 像 a.b 就无效</p></li></ul>',7)]))}const h=i(o,[["render",t]]);export{m as __pageData,h as default};
