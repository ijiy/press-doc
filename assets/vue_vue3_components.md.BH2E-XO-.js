import{_ as l,c as o,a0 as i,o as d}from"./chunks/framework.Bakaa70P.js";const m=JSON.parse('{"title":"vue3 【组件】","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue3/components.md","filePath":"vue/vue3/components.md","lastUpdated":1716256931000}'),c={name:"vue/vue3/components.md"};function a(u,e,t,n,r,p){return d(),o("div",null,e[0]||(e[0]=[i('<h1 id="vue3-【组件】" tabindex="-1">vue3 【组件】 <a class="header-anchor" href="#vue3-【组件】" aria-label="Permalink to &quot;vue3 【组件】&quot;">​</a></h1><h2 id="组件分类" tabindex="-1">组件分类 <a class="header-anchor" href="#组件分类" aria-label="Permalink to &quot;组件分类&quot;">​</a></h2><ul><li><p><a href="#页面组件">页面组件</a></p></li><li><p>模块组件, 分为: 全局组件, 抽象组件</p><ul><li>全局组件, 通常定义于<code>src/components</code>下的vue文件</li><li>抽象组件, 是更小颗粒的细分, 甚至没有节点. 可以在页面组件, 全局组件, 抽象组件中使用</li></ul></li><li><p>组件的使用需要实例化, 也就意味着会有性能的开销</p><ul><li>正常组件实例化, 其性能开销的影响可以忽略不计</li><li>如果大量遍历使用组件, 并且其抽象组件也大量遍历, 那么一次渲染需要实例化组件的量也就非常庞大, 可能成百上千, 部分设备可能就会出现短暂的空白或再下一帧DOM更新出现空白</li></ul></li></ul><h2 id="页面组件" tabindex="-1">页面组件 <a class="header-anchor" href="#页面组件" aria-label="Permalink to &quot;页面组件&quot;">​</a></h2><ul><li><p>动态路由对应的页面要求使用<code>目录/index.vue</code>格式</p><ul><li><code>views/Aa/index.vue</code><ul><li>动态路由会引入<code>views</code>下的所有<code>index.vue</code>, 作为路由的<code>component</code></li></ul></li><li>抽象组件 <ul><li><code>views/Aa/Xy.vue</code></li></ul></li></ul></li><li><p>页面目录结构要根据路由结构合理嵌套, 理论上支持无限嵌套</p></li></ul><h2 id="全局组件" tabindex="-1">全局组件 <a class="header-anchor" href="#全局组件" aria-label="Permalink to &quot;全局组件&quot;">​</a></h2><ul><li><p>自动导入顶层组件, 其它归属于抽象组件, 以优化构建性能</p></li><li><p>组件结构</p><ul><li><code>components/diyXxx/XxxYyy.vue</code><ul><li>diyXxx, 分类目录</li><li>XxxYyy, 自动导入的组件</li></ul></li><li><code>components/diyXxx/components/NnMm.vue</code><ul><li>NnMm, 抽象组件</li></ul></li></ul></li></ul><h3 id="异步组件" tabindex="-1">异步组件 <a class="header-anchor" href="#异步组件" aria-label="Permalink to &quot;异步组件&quot;">​</a></h3><ul><li>分离异步组件为独立模块 <ul><li><code>defineAsyncComponent</code>, 控制文件只有在需要渲染时, 被加载 <ul><li>而这里的加载到渲染是一个过程, 需要结合<code>Suspense</code>弥补这个空缺 <ul><li>从<code>fallback</code>转到<code>异步组件</code>, 是一个回流, 要注意<code>使用场景</code></li><li><code>异步组件</code>使用顶层<code>await</code>请求接口, 更合理的等待组件加载完毕 (直接书写顶层await, 无需插件)</li></ul></li></ul></li><li><code>defineAsyncComponent(() =&gt; import())</code>, 构建结果, 该组件为单独的文件 <ul><li>所有<code>() =&gt; import()</code>引入的模块(包括js, vue等), 都会被构建为单独的文件, 且在需要用到的地方, 被加载</li></ul></li></ul></li></ul><blockquote><p>router官解: 不要在路由中使用异步组件 * <code>defineAsyncComponent</code> 应该用于自定义组件的引用, 而不是页面组件</p></blockquote><ul><li><p>使用场景</p><ul><li>初始渲染未显示的组件, 如 <code>dialog</code>, <code>tabs</code></li><li>渲染服务器数据的组件</li></ul></li><li><p><code>el-dialog</code></p><ul><li>不能添加<code>ref</code>, 否则无法获取到元素, 可在内部添加</li><li>不要在其外层容器添加<code>position</code>, 否则可能导致弹窗 位置错乱 或 层级错乱 <ul><li>位置错乱: 可添加<code>append-to-body</code>, 此时弹窗置于body下, 样式无法继承</li><li>层级错乱: 调整相关模块的<code>z-index</code></li></ul></li></ul></li></ul>',11)]))}const h=l(c,[["render",a]]);export{m as __pageData,h as default};
