import{_ as l,c as a,a0 as s,o}from"./chunks/framework.Bakaa70P.js";const F=JSON.parse('{"title":"vue3 【侦听与属性计算】","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue3/watcher.md","filePath":"vue/vue3/watcher.md","lastUpdated":1725956646000}'),n={name:"vue/vue3/watcher.md"};function c(t,e,i,p,r,d){return o(),a("div",null,e[0]||(e[0]=[s(`<h1 id="vue3-【侦听与属性计算】" tabindex="-1">vue3 【侦听与属性计算】 <a class="header-anchor" href="#vue3-【侦听与属性计算】" aria-label="Permalink to &quot;vue3 【侦听与属性计算】&quot;">​</a></h1><h2 id="watch" tabindex="-1"><code>watch</code> <a class="header-anchor" href="#watch" aria-label="Permalink to &quot;\`watch\`&quot;">​</a></h2><ul><li><p>明确侦听对象</p></li><li><p>侦听的响应式数据源, 可以是一个或多个的<code>响应式变量</code>或<code>响应式引用</code></p></li><li><p>当侦听的是 深层次响应式对象, 将自动使用深层侦听 (这里同样推荐 只保留对象顶层次访问的响应性, 即尽可能使用<code>shallowReactive</code>, 而不是<code>reactive</code>)</p><ul><li>deep: 2, 侦听到第二层对象</li></ul></li><li><p>侦听一个对象中的多个属性</p></li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai vp-code" tabindex="0"><code><span class="line"><span style="color:#A6E22E;">watch</span><span style="color:#F8F8F2;">(</span></span>
<span class="line"><span style="color:#F8F8F2;">	() </span><span style="color:#66D9EF;font-style:italic;">=&gt;</span><span style="color:#F8F8F2;"> [a.x, a.y],</span></span>
<span class="line"><span style="color:#FD971F;font-style:italic;">	arr</span><span style="color:#66D9EF;font-style:italic;"> =&gt;</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#F8F8F2;">		console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(arr[</span><span style="color:#AE81FF;">0</span><span style="color:#F8F8F2;">], arr[</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">]);</span></span>
<span class="line"><span style="color:#F8F8F2;">	},</span></span>
<span class="line"><span style="color:#F8F8F2;">	{</span></span>
<span class="line"><span style="color:#F8F8F2;">		immediate: </span><span style="color:#AE81FF;">true</span><span style="color:#F8F8F2;">,</span></span>
<span class="line"><span style="color:#F8F8F2;">	},</span></span>
<span class="line"><span style="color:#F8F8F2;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>开发经验 <ul><li>侦听绑定在当前组件上, 随着组件的销毁而停止, 无需关心停止侦听 <ul><li><code>keep-alive</code>, 或路由向前, 会存在看不到的组件, 而这些组件上的侦听器也会存在 <ul><li>此时, 侦听的对象, 如果是全局性的 (如 router, store), 那么应该做相应的条件处理 (如 判断激活的页面是否是当前组件)</li></ul></li></ul></li><li>操作性的动态显示组件, 不要在组件中通过<code>watch</code>侦听改变显示状态, 应该用<code>ref</code>操控组件</li><li>尽量避免使用侦听, 可以使用函数回调, <code>emits</code>等</li><li>不应该集合侦听 <ul><li>反面教材: <code>watch(() =&gt; props)</code></li><li>正确做法: 分开侦听, 并尽可能侦听准确目标 <code>watch(() =&gt; props.a.b)</code></li></ul></li><li>避免侦听全局性数据 <ul><li>如<code>router</code>, 可以使用<code>onBeforeRouteUpdate</code></li></ul></li><li>非<code>immediate</code>, 尽可能改成函数回调触发, 或调用<code>provide</code>注入的函数, 也可以使用<code>mitt</code></li></ul></li></ul><h2 id="computed" tabindex="-1">computed <a class="header-anchor" href="#computed" aria-label="Permalink to &quot;computed&quot;">​</a></h2><ul><li><p>声明计算属性</p></li><li><p>相当于<code>watch</code> + <code>immediate: true</code> + <code>deep: true</code>的简化版, 只不过前者返回一个响应式对象, 这不仅简化侦听, 同时速声明了一个响应式对象</p></li><li><p>计算返回的结果是一个<code>ref</code>, 作为属性值</p><ul><li>vue2, 只是参与标签的属性值</li><li>vue3, 也可以参与CSS规则的属性值</li></ul></li><li><p>创建一个<code>只读的计算属性</code></p><ul><li>创建 <code>const a = computed(() =&gt; xx.value);</code></li><li>使用 <code>a.value</code></li><li>这是最常见的一种方式</li></ul></li><li><p>创建一个<code>可写的计算属性</code></p><ul><li>创建 <code>const a = computed({ get() {return props.modelValue;}, set(val) {emit(&#39;update:modelValue&#39;, val);} })</code></li><li>使用 <code>a.value = true;</code></li><li>通常配合<code>v-model</code>使用</li></ul></li></ul><h2 id="watcheffect" tabindex="-1">watchEffect <a class="header-anchor" href="#watcheffect" aria-label="Permalink to &quot;watchEffect&quot;">​</a></h2><ul><li>避免使用, 除非包含多个侦听的对象</li></ul>`,9)]))}const m=l(n,[["render",c]]);export{F as __pageData,m as default};
